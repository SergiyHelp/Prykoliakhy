<!DOCTYPE html>
<html>
	<head lang="uk">
		<meta charset="utf-8"/>
		<title>Алгоритм Еллера</title>
		<style>
:root { --accent: #fe8019; }
		</style>
		<link rel="stylesheet" href="style.css">
		<link rel="icon" href="images/icon.svg">
		<meta name="author" content="serhiy help">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="
					Блог зі статтями на різні цікаві теми:
					програмування, алгоритми, процедурна генерація, математика, геометрія.">
	</head>
	<body>
		<header>
			<a href="index.html"><img src="images/icon.svg" height=30em /></a>
		</header>
		<main>
			<h1>Алгоритм Еллера</h1>
<h2>Суть алгоритму</h2>
<h3>Вступ</h3>
<p>Алгоритм еллера — це алгоритм для генерації <em>ідеальних лабіринтів</em>.
Ідеальними лабіринтами називають такі, які не мають закритих областей
(таких в які не можна потрапити з іншої частини лабіринту)
та циклів (тобто, між будь-якими двома точками є лише один можливий шлях).</p>
<h3>Як працює алгоритм</h3>
<p>Лабіринт створюється ряд за рядом.</p>
<p>Спершу потрібно взяти перший ряд, і присвоїти кожній клітинці в ньому свою групу.
<img src="images/eller-1.webp" alt="Перший ряд з унікальними групами" />
Після цього групи ми рухаємось з ліва на право і розставляємо стінки справа.
Якщо ми прийняли рішення не додавати стінку, то групи необхідно об'єднати.
<img src="images/eller-2.webp" alt="Перший ряд із стінками та об'єднаними групами" />
Потім потрібно додати нижні стінки, кожна група повинна мати хоч одну дірку знизу,
інакше утвориться закрита зона.
<img src="images/eller-3.webp" alt="Перший ряд із нижніми стінками" />
Після цього ми копіюємо групи до нижнього ряду, лише там де ряд має дірки знизу.
<img src="images/eller-4.webp" alt="Другий ряд з копіями груп" />
Клітинки, які залишились заповнюємо новими групами.
<img src="images/eller-5.webp" alt="Другий ряд, повністю заповнений групами" />
Після цього ми знову розставляємо стінки справа.
І якщо дві сусідні клітинки мають різні групи, то ми можемо поставити між ними стінку,
<img src="images/eller-6.webp" alt="" />
або об'єднати їх в одну групу.
<img src="images/eller-7.webp" alt="" />
Якщо ж сусідні клітинки належать до однієї групи,
<img src="images/eller-8.webp" alt="" />
то ми <strong>зобов'язані</strong> поставити між ними стінку, щоб уникнути зациклення лабіринту.
<img src="images/eller-9.webp" alt="" />
Після цього ми знову розствляємо нижні стінки. При чому кожна група повинна мати хоч одну дірку знизу.
<img src="images/eller-10.webp" alt="" />
Також, коли ми хочемо об'єднати дві групи потрібно об'єнувати змінити групу у всіх клітинках
які належать до групи. На відміну від того, що показано на зображенні не потрібно змінювати групи
в попередніх рядках. Проте потрібно змінити всі клітинки в ряді з яким ми зараз працюємо
<img src="images/eller-11.webp" alt="" />
<img src="images/eller-12.webp" alt="" />
Таким чином ми можемо продовжувати додаючи нові ряди.
<img src="images/eller-13.webp" alt="" />
Коли ми хочемо додати останній ряд, тепер ми повинні завжди об'єднувати дві сусідні групи,
якщо вони різні, чи ставити стінку якщо вони однакові.
<img src="images/eller-14.webp" alt="" />
Так як нижній ряд останній в лабіринті, кожна клітинка в ньому повинна мати стінку знизу.
<img src="images/eller-15.webp" alt="" /></p>
<h2>Підумок</h2>
<p>Алгоритм еллера створює лабіринти високої якості. Ось декілька прикладів:
<img src="images/eller-maze.webp" alt="" />
<img src="images/eller-maze2.webp" alt="" /></p>
<p>Також, ось реалізація алгоритму на GDscript:</p>
<pre><code><span class="word">func</span> eller(rows: int, cols: int) -&gt; Array:
	<span class="word">var</span> maze = create_array2D(rows, cols)
	<span class="word">var</span> free_group = 0

	<span class="word">for</span> i <span class="word">in</span> rows:
		<span class="word">var</span> row = maze[i]

		<span class="comment"># Спершу, потрібно заповнити ряд групами</span>
		<span class="word">if</span> i == 0:  <span class="comment"># Якщо це перший рядок: зоповнити його повністю новими значеннями</span>
			<span class="word">for</span> j <span class="word">in</span> cols:
				row[j].group = free_group
				free_group += 1
		<span class="word">else</span>:   <span class="comment"># Інакше, копіювати групи з попереднього рядка там, де немає нижньої стінки.</span>
			<span class="word">for</span> j <span class="word">in</span> cols:
				<span class="word">if</span> maze[i - 1][j].has_bottom_wall:
					row[j].group = free_group
					free_group += 1
				<span class="word">else</span>:   <span class="comment"># Клітинки, які залишились, заповнити новими групами</span>
					row[j].group = maze[i - 1][j].group

		<span class="comment"># Потім - додати бокові стінки</span>
		<span class="word">for</span> j <span class="word">in</span> cols:
			<span class="comment"># Додати стінку якщо:</span>
			<span class="comment"># це остання клітинка</span>
			<span class="comment"># АБО наступна клітинка має таку ж групу</span>
			<span class="comment"># АБО випадково ПРИ УМОВІ що це не останній рядок</span>
			<span class="word">if</span> j == cols - 1 || row[j].group == row[j + 1].group || (i &lt; rows - 1 &amp;&amp; deside()):
				row[j].has_right_wall = true
			<span class="word">else</span>:
				<span class="word">var</span> target_group = row[j + 1].group
				<span class="word">for</span> x <span class="word">in</span> cols:
					<span class="word">if</span> row[x].group == target_group:
						row[x].group = row[j].group

		<span class="comment"># І додати стінки знизу</span>
		<span class="word">if</span> i &lt; rows - 1:
			<span class="word">for</span> j <span class="word">in</span> cols:
				<span class="word">if</span> row[j].has_right_wall:
					<span class="word">var</span> group_has_hole = false
					<span class="word">for</span> x <span class="word">in</span> j:
						<span class="word">if</span> row[x].has_bottom_wall == false &amp;&amp; row[x].group == row[j].group:
							group_has_hole = true
					row[j].has_bottom_wall = deside() <span class="word">if</span> group_has_hole <span class="word">else</span> false
					group_has_hole = false
				<span class="word">elif</span> deside():
					row[j].has_bottom_wall = true
		<span class="word">else</span>:
			<span class="word">for</span> j <span class="word">in</span> cols:
				row[j].has_bottom_wall = true
	<span class="word">return</span> maze
</code></pre>
<pre><code><span class="word">class</span> MazeCell:
	<span class="word">extends</span> Reference

	<span class="word">export</span> <span class="word">var</span> group : int
	<span class="word">export</span> <span class="word">var</span> has_bottom_wall : bool
	<span class="word">export</span> <span class="word">var</span> has_right_wall : bool
</code></pre>
<pre><code><span class="word">func</span> deside() -&gt; bool:
	<span class="word">return</span> randf() &gt; 0.5
</code></pre>
<pre><code><span class="word">func</span> create_array2D(rows: int, cols: int) -&gt; Array:
	<span class="word">var</span> arr = []
	<span class="word">for</span> i <span class="word">in</span> rows:
		arr.append([])
		<span class="word">for</span> j <span class="word">in</span> cols:
			arr[i].append(MazeCell.new())
	<span class="word">return</span> arr
</code></pre>

<div class="cycle"> Стаття з циклу: <a href="index.html#heneratsiia-labiryntiv">Генерація лабіринтів</a> </div>
<div class="navigation">
    
    
</div>

		</main>
		<footer>
			<div>
				Підтримай автора:<br>
				<a href="https://privatbank.ua/sendmoney?payment=4f11f2ed6d">
					<img class="icon" src="images/privat.svg">ПриватБанк Sendmoney
				</a>
			</div>
			<div>
				Є питання чи пропозиції?<br>
				<a href="mailto:sergiyhelp@gmail.com">
					<img class="icon" src="images/email.svg">sergiyhelp@gmail.com
				</a>
			</div>
			<div>
				Подпишись на новини:<br>
				<a href="https://t.me/prykoliakhy">
					<img class="icon" src="images/telegram.svg">Telegram
				</a>
			</div>
		</footer>
	</body>
</html>
