<!DOCTYPE html>
<html>
	<head lang="uk">
		<meta charset="utf-8"/>
		<title>Рекурсивний пошук з поверненням</title>
		<style>
:root { --accent: #8ec07c; }
		</style>
		<link rel="stylesheet" href="style.css">
		<link rel="icon" href="images/icon.svg">
		<meta name="author" content="serhiy help">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="
					Інтернет журнал зі статтями на різні цікаві теми:
					програмування, алгоритми, процедурне генерування, математика, геометрія.">
	</head>
	<body>
		<header>
			<a href="index.html"><img src="images/icon.svg" alt="На головну" height=30em /></a>
		</header>
		<main>
			<h1>Рекурсивний пошук з поверненням</h1>
<h2>Вступ</h2>
<p>Рекурсивний пошук з поверненням (Reverce backtracking) —
це чи не найпростіший алгоритм для генерації ідеальних лабіринтів.
Лабіринти, які він утворює мають довші ходи у порівнянні з <em>алгоритмом Еллера</em>.
Окрім того, алгоритм з легкістю можна модифікувати для генерації
лабіринтів з розмірністю вищою ніж 2D, чи лабіринтів на неквадратній сітці.
Проте, він зовсім не підходить для генерації безкінечних лабіринтів.</p>
<p>Ось декілька лабіринтів, створених цим алгоритмом:</p>
<p><img src="images/backtrack-maze-10.webp" alt="Лабіринт 10х10" />
<img src="images/backtrack-maze-20.webp" alt="Лабіринт 20х20" />
<img src="images/backtrack-maze-40.webp" alt="Лабіринт 40х40" /></p>
<h2>Алгоритм та код</h2>
<h3>Словесний опис</h3>
<p>На початку роботи всі клітинки в нашому лабіринті закриті стінками.
В процесі виконання ми будемо прорізати крізь них ходи.
Для цього алгоритм використовує покажчик на певну клітинку.
Для зручності, назвімо його, наприклад, <em>щуром</em>.</p>
<p><img src="images/backtrack-01.webp" alt="Щур на початковій позиції" /></p>
<p>Наш щур рухається по лабіринту,
переміщаючись на сусідні клітинки, на яких він ще не був.
При цьому він руйнує стінку між ними.
Клітинки, які вже були відвідані потрібно якось позначати.
В цьому прикладі вони замальовані трохи темнішим кольором.
Окрім того, щур пам'ятає свій пройдений шлях,
як стек куди він заносить відвідані клітинки (<em>стек шляху</em>).
На зображеннях шлях щура зображений як коричнева лінія.</p>
<p>На кожному своєму кроці щур оглядає чотири навколишні клітинки,
та випадково обирає одну, серед тих, до яких він ще не заходив.
Він руйнує стінку в тому напрямку та переміщується на обрану клітинку.
А клітинку, яку він щойно залишив, додає до <em>стеку шляху</em>.</p>
<p><img src="images/backtrack-02.webp" alt="Щур та його шлях" /></p>
<p>Якщо ж щуру немає куди йти, так як усі сусідні клітинки зайняті,
то він рухається назад звідки він прийшов, та відкидає ці клітинки зі <em>стеку шляху</em>.
Так, він рухається задом на перед, до тих пір,
поки знову не знайде клітинку, біля якої є ще не відвідані
клітинки, та піде в одну з них.</p>
<p><img src="images/backtrack-03.webp" alt="Щур повертається назад" /></p>
<p>Після багаторазових проходжень та повернень назад,
щур врешті-решт повернеться до самого
початку лабіринту, а його <em>стек шляху</em> буде порожнім.
Це й буде свідчити про те, що алгоритм завершив свою роботу.</p>
<p><img src="images/backtrack-04.webp" alt="Щур блукає по лабіринту" />
<img src="images/backtrack-05.webp" alt="Закінчений лабіринт" /></p>
<h3>Програмний код</h3>
<p>Також, ви можете скористатись моїм виконанням цього алгоритму на мові GDScript:</p>
<pre><code><span class="word">func</span> backrtack(width: int, height: int) -&gt; Array:
	<span class="word">var</span> maze = create_array2D(width, height)
	<span class="word">var</span> trail : Array = [] <span class="comment"># Шлях пройдений щуром</span>
	<span class="word">var</span> position : Vector2 = Vector2.ZERO <span class="comment"># Розташування щура</span>

	<span class="word">while</span> <span class="word">true</span>:
		<span class="comment"># 0 — Вліво 1 — Вправо 2 — Вгору 3 — Вниз</span>
		<span class="word">var</span> possible_directions : Array = []

		<span class="comment"># Шукаємо невідвідані клітинки серед сусідніх</span>
		<span class="word">if</span> position.x &gt; 0 &amp;&amp; maze[position.x - 1][position.y].visited == <span class="word">false</span>:
			possible_directions.append(0)
		<span class="word">if</span> position.x &lt; width - 1 &amp;&amp; maze[position.x + 1][position.y].visited == <span class="word">false</span>:
			possible_directions.append(1)
		<span class="word">if</span> position.y &gt; 0 &amp;&amp; maze[position.x][position.y - 1].visited == <span class="word">false</span>:
			possible_directions.append(2)
		<span class="word">if</span> position.y &lt; height - 1 &amp;&amp; maze[position.x][position.y + 1].visited == <span class="word">false</span>:
			possible_directions.append(3)

		<span class="comment"># Якщо всі сусіди зайняті — повертаймось назад</span>
		<span class="word">if</span> possible_directions.size() == 0:
			maze[position.x][position.y].visited = <span class="word">true</span>
			position = trail.pop_back()
			<span class="comment"># Якщо щур знову в точці (0,0) — то потрібно закінчити роботу</span>
			<span class="word">if</span> position == Vector2.ZERO:
				<span class="word">break</span>
		<span class="word">else</span>:
			<span class="comment"># Серед доступних напрямків випадково оберімо один</span>
			<span class="word">var</span> dirrection = random_among(possible_directions)

			<span class="comment"># Та перейдімо по ньому</span>
			<span class="word">match</span> dirrection:
				0:
					trail.push_back(position)
					maze[position.x][position.y].visited = <span class="word">true</span>
					position.x -= 1
					maze[position.x][position.y].has_way_right = <span class="word">true</span>
				1:
					trail.push_back(position)
					maze[position.x][position.y].visited = <span class="word">true</span>
					position.x += 1
					maze[position.x - 1][position.y].has_way_right = <span class="word">true</span>
				2:
					trail.push_back(position)
					maze[position.x][position.y].visited = <span class="word">true</span>
					position.y -= 1
					maze[position.x][position.y].has_way_bottom = <span class="word">true</span>
				3:
					trail.push_back(position)
					maze[position.x][position.y].visited = <span class="word">true</span>
					position.y += 1
					maze[position.x][position.y - 1].has_way_bottom = <span class="word">true</span>

	<span class="word">return</span> maze
</code></pre>
<p>У коді також використовуються 2 методи.
Для створення масиву масивів:</p>
<pre><code><span class="word">func</span> create_array2D(width: int, height: int) -&gt; Array:
	<span class="word">var</span> arr = []
	<span class="word">for</span> x <span class="word">in</span> width:
		arr.append([])
		<span class="word">for</span> y <span class="word">in</span> height:
			arr[x].append(MazeCell.new())
	<span class="word">return</span> arr
</code></pre>
<p>Та для вибору випадкового елементу з масиву:</p>
<pre><code><span class="word">func</span> random_among(arr : Array) -&gt; int:
	<span class="word">return</span> arr[randi() % arr.size()];
</code></pre>
<p>Для реалізації клітинки лабіринту використовується ось такий клас:</p>
<pre><code><span class="word">class</span> MazeCell:
	<span class="word">extends</span> Reference

	<span class="word">export</span> <span class="word">var</span> visited : bool
	<span class="word">export</span> <span class="word">var</span> has_way_bottom : bool
	<span class="word">export</span> <span class="word">var</span> has_way_right : bool
</code></pre>

<div class="cycle-reference"> Стаття з циклу: <a href="index.html#ctvorennia-labiryntiv">Створення лабіринтів</a> </div>
<nav>
    <a class="btn" href="alhorytm-ellera.html">Попередня стаття</a>

    
</nav>

		</main>
		<footer>
			<div>
				Підтримай автора:
				<ul>
					<li>
						<a href="https://privatbank.ua/sendmoney?payment=4f11f2ed6d">
							<img class="icon" alt="privat" src="images/privat.svg">ПриватБанк Sendmoney
						</a>
					</li>
				</ul>
			</div>
			<div>
				Є питання чи пропозиції?
				<ul>
					<li>
						<a href="mailto:sergiyhelp@gmail.com">
							<img class="icon" alt="email" src="images/email.svg">sergiyhelp@gmail.com
						</a>
					</li>
				</ul>
			</div>
			<div>
				Подпишись на новини:
				<ul>
					<li>
						<a href="https://t.me/prykoliakhy">
							<img class="icon" alt="tg" src="images/telegram.svg">Telegram
						</a>
					</li>
				</ul>
			</div>
		</footer>
	</body>
</html>
