<!DOCTYPE html>
<html>
<head lang="uk">
    <meta charset="utf-8"/>
    <title>Алгоритм Еллера</title>
    <style>
        :root { --accent: #d3869b; }
    </style>
    <link rel="stylesheet" href="/style.css">
    <link rel="icon" href="/images/icon.svg">
    <meta name="author" content="serhiy help">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="
    Блог зі статтями на різні цікаві теми: програмування, алгоритми, процедурна генерація, математика, геометрія.">
</head>
<body>
    <header>
        <a href="/index.html"><img src="/images/icon.svg" height=30em /></a>
    </header>
    <main>
        <h1>Алгоритм Еллера</h1>
<h2>Вступ</h2>
<p>Алгоритм Еллера — це математичний генератор, що дозволяє створювати лабіринти,
у яких між кожними двома точками існує єдиний шлях, тобто лабіринти не містять
циклів. У порівнянні з іншими генераторами, цей алгоритм є одним із найшвидших
та потребує незначну кількість пам'яті — пропорційну довжині рядка лабіринту.
Потрібно зберігати в пам'яті лише останній створений рядок — це дозволяє
генерувати лабіринти з необмеженою кількістю рядків.</p>
<p>Алгоритм являє собою цикл додавання нових рядків. Рядок містить одну і ту саму
кількість клітинок, яка довільно задається на початку. Клітинки належать до
множин, що слугують для контролю можливості проходу між клітинками. На момент
генерації поточного рядка клітини однієї множини з'єднані між собою, водночас
клітини з різних множин знаходяться в ізольованих між собою частинах лабіринту.
У кожної клітинки може бути або не бути права та нижня стінка. Загалом, стінки
генеруються випадковим чином, але при дотриманні певних правил, які гарантують
відсутність циклів у лабіринті.</p>
<p><img src="/images/img.webp" alt="fish" /></p>
<pre><code><span class="word">func</span> eller(rows: int, cols: int) -&gt; Array:
	<span class="word">var</span> maze = create_array2D(rows, cols)
	<span class="word">var</span> free_group = 0

	<span class="word">for</span> i <span class="word">in</span> rows:
		<span class="word">var</span> row = maze[i]

		<span class="comment"># Спершу, потрібно заповнити ряд групами</span>
		<span class="word">if</span> i == 0:  			<span class="comment"># Якщо це перший рядок: зоповнити його повністю новими значеннями</span>
			<span class="word">for</span> j <span class="word">in</span> cols:
				row[j].group = free_group
				free_group += 1
		<span class="word">else</span>:   				<span class="comment"># Інакше, копіювати групи з попереднього рядка там, де немає нижньої стінки.</span>
			<span class="word">for</span> j <span class="word">in</span> cols:
				<span class="word">if</span> maze[i - 1][j].has_bottom_wall:
					row[j].group = free_group
					free_group += 1
				<span class="word">else</span>:   		<span class="comment"># Клітинки, які залишились, заповнити новими групами</span>
					row[j].group = maze[i - 1][j].group

		<span class="comment"># Потім - додати бокові стінки</span>
		<span class="word">for</span> j <span class="word">in</span> cols:
			<span class="comment"># Додати стінку якщо:</span>
			<span class="comment"># це остання клітинка</span>
			<span class="comment"># АБО наступна клітинка має таку ж групу</span>
			<span class="comment"># АБО випадково ПРИ УМОВІ що це не останній рядок</span>
			<span class="word">if</span> j == cols - 1 || row[j].group == row[j + 1].group || (i &lt; rows - 1 &amp;&amp; deside()):
				row[j].has_right_wall = true
			<span class="word">else</span>:
				<span class="word">var</span> target_group = row[j + 1].group
				<span class="word">for</span> x <span class="word">in</span> cols:
					<span class="word">if</span> row[x].group == target_group:
						row[x].group = row[j].group

		<span class="comment"># І додати стінки знизу</span>
		<span class="word">if</span> i &lt; rows - 1:
			<span class="word">for</span> j <span class="word">in</span> cols:
				<span class="word">if</span> row[j].has_right_wall:
					<span class="word">var</span> group_has_hole = false
					<span class="word">for</span> x <span class="word">in</span> j:
						<span class="word">if</span> row[x].has_bottom_wall == false &amp;&amp; row[x].group == row[j].group:
							group_has_hole = true
					row[j].has_bottom_wall = deside() <span class="word">if</span> group_has_hole <span class="word">else</span> false
					group_has_hole = false
				<span class="word">elif</span> deside():
					row[j].has_bottom_wall = true
		<span class="word">else</span>:
			<span class="word">for</span> j <span class="word">in</span> cols:
				row[j].has_bottom_wall = true
	<span class="word">return</span> maze
</code></pre>
<p>До початку воєнних дій російський Балтійський флот значно поступався німецькому
кайзерівському флоту, тому усі його плани будувалися з розрахунку на підтримку
дій своїх наземних сил. Втім, кайзерівський флот для дій на Балтійському
морі обмежився незначним угрупованням бойових кораблів, яке виконувало
другорядні завдання. З початку серпня 1914 року розпочалися бойові дії, які
скоріше мали характер розвідки боєм, ніж повномасштабних бойових зіткнень
флотів двох держав. Протягом кампанії 1914 року російський Балтійський флот
перейшов від пасивного очікування противника в гирлі Фінської затоки до
активних дій на всій акваторії мо
<div class="cycle"> Стаття з циклу: <a href="/cycles/heneratsiia-labiryntiv.html">Генерація лабіринтів</a> </div>
<div class="navigation">
    
    
</div>

    </main>
    <footer>
        <div>
            <p>Підтримай автора:</p>
            <p><a href="https://privatbank.ua/sendmoney?payment=4f11f2ed6d"><img class="icon" src="/images/privat.svg">ПриватБанк Sendmoney</a></p>
        </div>
        <div>
            <p>Є питання чи пропозиції?</p>
            <p><a href="mailto:sergiyhelp@gmail.com"><img class="icon" src="/images/email.svg">sergiyhelp@gmail.com</a></p>
        </div>
        <div>
            <p>Подпишись на новини:</p>
            <p><a href="https://t.me/prykoliakhy"><img class="icon" src="/images/telegram.svg">Telegram</a></p>
        </div>
    </footer>
</body>
</html>
