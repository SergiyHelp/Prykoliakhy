Алгоритм квадрата-ромба
=======================

## Алгоритм зміщення серединної точки

### Спрощена версія

Перш ніж вести мову за алгоритм квадрата-ромба
варто розібратись з *алгоритмом зміщення серединної точки* (midpoint displasement).
Найпростіший варіант цього алгоритму працює зі списком висот.
Він підходить для того, щоб створювати рівні для двовимірних ігор чи ліній горизонту.

![Анімація виконання алгоритму](images/midpoint-displacement.webp)

### Як працює алгоритм

Алгоритм описує ландшафт як список висот точок.
Такий список може мати довжину 2<sup>n</sup>+1.
Щоби зробити ландшафт іншої довжини,
можна згенерувати ландшафт більшого розміру та обрізати його частину.

Спершу, почнімо зі списку вершин, який містить два елемента —
їх значення будуть висотами по краям землі.
Потім, додаймо новий елемент до списку між ними.
Значення цього елемента буде дорівнювати середньому арифметичному значень елементів між якими він знаходиться
плюс випадкове зміщення.
Величина цього зміщення залежить від ітерації алгоритму: з кожною ітерацією вона падає.
На мою думку, найкраще, коли вона падає в геометричній прогресії - в два рази на кожній ітерації.

Тепер, після того як ми додали нову вершину, наш список містить три вершини,
а значить — алгоритм закінчив свою першу ітерацію.

Далі, на другій ітерації, ми повинні вставити нові вершини між старими,
розширивши список до п'яти вершин.
Значення цих вершин обраховується у спосіб зазначений вище.

Так можна продовжувати далі, ітерація за ітерацією.
Додаючи нові деталі до ландшафту.

### Реалізація

Наведений код написаний на мові GDScript.

```
func generate(subdivisions: int, roughness: float, land_seed: int) -> Array:
	var random = RandomNumberGenerator.new()
	random.seed = land_seed

	var land: Array = []

	# Крайні точки списку
	land.append(randf())
	land.append(randf())

	for n in subdivisions:
		var i: int = 0
		while i < land.size() - 1:
			var left = land[i]
			var right = land[i + 1]
			var mid = (left + right) * 0.5
			# roughness — множник, який регулює шершавість
			# На анімації вище roughness = 0.2
			mid += random.randfn() / pow(2, n) * roughness
			#нова точна вставляється між старими
			land.insert(i + 1, mid)
			# індекс потрібно збільшити на 2 так як з'явився новий елемент
			i += 2

	return land
```

## Алгоритм зміщення серединної точки (двовимірний)

### Розширена версія

Розширена версія алгоритму працює для прямокутників зі сторонами 2<sup>n</sup>+1.
Взагалі, алгоритм можна розширювати далі, для роботи з вищими розмірностями.
У такий спосіб можна генерувати печери, туманності та хмари газу.

![Анімація генерації ландшафту ЗСТ2](images/midpoint-displacement-2d.webp)

Якщо раніше ми розглядали відрізок на двох точках, який ми розбивали на два нових відрізка,
то тепер, ми працюємо з квадратом, який ми маємо розбити на чотири нових.
Для цього нам потрібно знайти одну точку в центрі квадрата, та чотири - на ребрах.
Значення центральної точки дорівнює середньому арифметичному значень кутових точок плюс зміщення.
Зміщення шукається так само як і в оригінальній версії алгоритму.
Значення ж точок на ребрах — це середнє значення **двох** точок на прилеглих до ребра кутах плюс зміщення.

Мовою GDScript це можна записати ось так:

```
func generate(subdivisions: int, roughness: float, land_seed: int) -> Array:
	var rng = RandomNumberGenerator.new()
	rng.seed = land_seed

	#розмір одної сторони отриманого шматка землі
	var p_size = pow(2, subdivisions) + 1

	#підготовка масиву масивів чисел
	var map = []
	for x in p_size:
		map.append([])
		for y in p_size:
			map[x].append(0)

	while subdivisions > 1:
		subdivisions -= 1
		var i  = int(pow(2, subdivisions - 1))

		# центри
		for x in range(i, p_size - i, i * 2):
			for y in range(i, p_size - i, i * 2):
				map[x][y] = (map[x-i][y-i] + map[x-i][y+i] + map[x+i][y-i] + map[x+i][y+i]) * 0.25
				map[x][y] += rng.randfn() * roughness

		#вертикалі
		for x in range(0, p_size, i * 2):
			for y in range(i, p_size - i, i * 2):
				map[x][y] = (map[x][y+i] + map[x][y-i]) * 0.5
				map[x][y] += rng.randfn() * roughness

		#горизонталі
		for x in range(i, p_size - i, i * 2):
			for y in range(0, p_size, i * 2):
				map[x][y] = (map[x+i][y] + map[x-i][y]) * 0.5
				map[x][y] += rng.randfn() * roughness

		roughness *= 0.5

	return map
```

### Обмеження

З першого погляду на створену мапу видно, що алгоритм тяжіє до ортогональних ліній.
Гірські хребти та долини простягаються прямо паралельно сторонам квадрата в якому вони знаходяться.
До того ж, при підвищенні деталізації, поверхня стає все більш шершавою.
Тому після генерації отриману поверхню варто якимось чином розгладити.

![Вид зверху на землю](images/md-2d-top-view.webp)
![Вид зверху на землю](images/md2-top-view2.webp)

## Власне алгоритм квадрата-ромба

### Вирішення проблем

Алгоритм зміщення серединної точки залишає багато прямих ліній на створеній карті.
Так стається, тому що деякі точки беруть своє значення на основі значень чотирьох своїх сусідів,
а деякі — лише двох.
Алгоритм *квадрата-ромба* — це покращена версія алгоритму зміщення серединної точки,
яка вирішує вище згадану проблему.

![Алгоритм квадрата-ромба](images/diamond-square.webp)

Кожна ітерація цього алгоритму проходить у два етапи:
На першому ми знаходимо середини всіх квадратів,
використовуючи значення всіх чотирьох кутів кожного з них.
На другому — ми знаходимо точки на ребрах.
Їх значення визначається на основі двох точок на кінцях ребра
а також на основі двох центрів тих квадратів, що ділять це ребро.

По краям карти, нашим точкам немає звідки взяти одну з чотирьох сусідніх точок.
Існує декілька способів вирішити цю проблему.
Можна просто проігнорувати четверту точку і взяти середнє арифметичне лише від трьох інших значень.
Або можна вважати її значення рівним нулю чи будь-якому іншому числу.
Або ж взяти значення точки з протилежного кінця карти.
Тоді карта буде зацикленою.
З точки зору топології така карта матиме форму тора.

В наведеному нижче коді використовується другий спосіб: точки за межами карти мають значення **нуль**.

```
func generate(subdivisions: int, roughness: float, land_seed: int) -> Array:
	var rng = RandomNumberGenerator.new()
	rng.seed = land_seed

	#розмір одної сторони отриманого шматка землі
	var p_size = pow(2, subdivisions) + 1
	#підготовка масиву масивів чисел
	var map = []
	for x in p_size:
		map.append([])
		for y in p_size:
			map[x].append(0)

	while subdivisions > 1:
		subdivisions -= 1
		var i  = int(pow(2, subdivisions - 1))

		# квадрати
		for x in range(i, p_size - i, i * 2):
			for y in range(i, p_size - i, i * 2):
				map[x][y] = (map[x-i][y-i] + map[x-i][y+i] + map[x+i][y-i] + map[x+i][y+i]) * 0.25
				map[x][y] += rng.randfn() * roughness

		# ромби
		var allow: bool = false # дозволяє операції через раз
		for x in range(0, p_size, i):
			for y in range(0, p_size, i):
				if allow:
					if x > 0:
						map[x][y] += map[x-i][y]
					if x < p_size - 1:
						map[x][y] += map[x+i][y]
					if y > 0:
						map[x][y] += map[x][y-i]
					if y < p_size - 1:
						map[x][y] += map[x][y+i]

					map[x][y] *= 0.25
					map[x][y] += rng.randfn() * roughness
				allow = !allow

		roughness *= 0.5

	return map
```

### Особливості отриманих земель

Землі, отримані в такий спосіб, не мають чітко виражених прямих ліній.
Але й вони мають свої вади.

![Алгоритм квадрата-ромба](images/ds-top-view.webp)

По перше, якщо вирішити проблему країв мапи, в той спосіб, який використаний у коді вище,
то по краям можуть утворитись ось такі дивні артефакти:

![Алгоритм квадрата-ромба](images/ds-wierd-border.webp)

Ну і навіть ця, найкраща форма алгоритму не вирішує проблему шершавості.
Ба більше, землі, створені нею, навіть шершавіші.
А значить, утворену поверхню просто необхідно розгладити.

Найпростіший спосіб це зробити — піднести значення точок до квадрату.
Від цього гори стануть крутішими а рівнини — пологішими,
також, щоб гірські піки не здіймалися вже зовсім високо,
потрібно зжати всі точки так, щоб значення їх висот знаходились в межах від 0 до 1.

Погравшись зі значеннями я зміг отримати ландшафт, схожий на аерофотозйомку поверхні Марса.

![Алгоритм квадрата-ромба](images/mars-land.webp)


