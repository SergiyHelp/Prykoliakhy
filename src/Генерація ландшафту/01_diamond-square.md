# Алгоритм квадрата-ромба

## Алгоритм зміщення серединної точки

Перш ніж вести мову за алгоритм квадрата-ромба
варто розібратись з *алгоритмом зміщення серединної точки* (midpoint displasement).
Найпростіший варіант цього алгоритму працює зі списком висот.
Він підходить для того, щоб створити ландшафт для 2D гри або для створення лінії обрію.

![Анімація виконання алгоритму](images/midpoint-displasement.webp)

### Як працює алгоритм

Списки висот, які утворює цей алгоритм,
мають довжину 2<sup>n</sup>+1.
Щоби зробити ландшафт іншої довжини,
можна згенерувати ландшафт більшого розміру та обрізати його частину.

Спершу, ми почнімо зі списку вершин, який містить два елемента —
їх значення будуть висотами по краям землі.
Потім, додаймо новий елемент до списку між ними.
Значення цього елемента буде дорівнювати середньому арифметичному значень елементів між якими він знаходиться
плюс випадкове зміщення.
Величина цього зміщення залежить від ітерації алгоритму: з кожною ітерацією вона падає.
На мою думку, найкраще, коли вона падає в геометричній прогресії - в два рази на кожній ітерації.

Тепер, після того як ми додали нову вершину, наш список містить три вершини,
а значить — алгоритм закінчив свою першу ітерацію.

Далі, на другій ітерації, ми повинні вставити нові вершини між старими,
розширивши список до п'яти вершин.
Значення цих вершин обраховується у спосіб зазначений вище.

Так можна продовжувати далі, ітерація за ітерацією.
Додаючи нові деталі до ландшафту.

### Реалізація

Наведений код написаний на мові GDScript.

```
func generate(subdivisions: int, roughness: float, land_seed: int) -> Array:
	var random = RandomNumberGenerator.new()
	random.seed = land_seed

	var land: Array = []

	# Крайні точки списку
	land.append(randf())
	land.append(randf())

	for n in subdivisions:
		var i: int = 0
		while i < land.size() - 1:
			var left = land[i]
			var right = land[i + 1]
			var mid = (left + right) * 0.5
			# roughness — множник, який регулює шершавість
			# На анімації вище roughness = 0.2
			mid += random.randfn() / pow(2, n) * roughness
			#нова точна вставляється між старими
			land.insert(i + 1, mid)
			# індекс потрібно збільшити на 2 так як з'явився новий елемент
			i += 2

	return land
```

## Алгоритм зміщення серединної точки (двовимірний)

Розширена версія алгоритму працює для прямокутників зі сторонами 2<sup>n</sup>+1.
Взагалі, алгоритм можна доповнювати далі, для роботи з вищими розмірностями.
У такий спосіб можна генерувати печери, туманності та хмари газу.

Якщо раніше ми розглядали відрізок на двох точках, який ми розбивали на два нових відрізка,
то тепер, ми працюємо з квадратом, який ми маємо розбити на чотири нових.
Для цього нам потрібно знайти одну точку в центрі квадрата, та чотири - на ребрах.
Значення центральної точки дорівнює середньому арифметичному значень кутових точок плюс зміщення.
Зміщення шукається так само як і в оригінальній версії алгоритму.
Значення ж точок на ребрах — це середнє значення **двох** точок на прилеглих до ребра кутах плюс зміщення.

## Власне алгоритм квадрата-ромба

В землях згенерованих алгоритмом зміщення серединної точки
деякі точки отримають своє значення на основі значень чотирьох інших точок а деякі - на основі двох.
Тому, якщо поглянути на результат роботи цього алгоритму в очі відразу кидаються ромбовидні структури, що утворюються на поверхні.
Як спосіб вирішити цю проблему був створений алгоритм *квадрата-ромба* (diamond-square).

Кожна ітерація цього алгоритму проходить у два етапи:
На першому ми знаходимо середини всіх квадратів, використовуючи значення всіх чотирьох кутів.
На другому - ми знаходимо точки на ребрах.
Їх значення визначається на основі двох точок на кутах квадрата,
а також на основі двох центрів в квадратах що містять ребро з нашою точкою.

По краям карти нашим точкам немає звідки взяти четверте значення.
Існує декілька способів вирішити цю проблему.
Можна просто проігнорувати четверту точку і взяти середнє арифметичне від трьох значень.
А можна, взяти її значення як рівне нулю, або взяти значення точки з протилежного кінця карти.
Тоді карта буде зацикленою і топологічно буде дорівнювати тору.
