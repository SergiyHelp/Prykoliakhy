# Алгоритм Еллера

## Вступ

Алгоритм Еллера — це математичний генератор, що дозволяє створювати лабіринти,
у яких між кожними двома точками існує єдиний шлях, тобто лабіринти не містять
циклів. У порівнянні з іншими генераторами, цей алгоритм є одним із найшвидших
та потребує незначну кількість пам'яті — пропорційну довжині рядка лабіринту.
Потрібно зберігати в пам'яті лише останній створений рядок — це дозволяє
генерувати лабіринти з необмеженою кількістю рядків.

Алгоритм являє собою цикл додавання нових рядків. Рядок містить одну і ту саму
кількість клітинок, яка довільно задається на початку. Клітинки належать до
множин, що слугують для контролю можливості проходу між клітинками. На момент
генерації поточного рядка клітини однієї множини з'єднані між собою, водночас
клітини з різних множин знаходяться в ізольованих між собою частинах лабіринту.
У кожної клітинки може бути або не бути права та нижня стінка. Загалом, стінки
генеруються випадковим чином, але при дотриманні певних правил, які гарантують
відсутність циклів у лабіринті.
![великий лабіринт](/images/eller-maze.webp)
![малий лабіринт](/images/eller-maze2.webp)

```
func eller(rows: int, cols: int) -> Array:
	var maze = create_array2D(rows, cols)
	var free_group = 0

	for i in rows:
		var row = maze[i]

		# Спершу, потрібно заповнити ряд групами
		if i == 0:  # Якщо це перший рядок: зоповнити його повністю новими значеннями
			for j in cols:
				row[j].group = free_group
				free_group += 1
		else:   # Інакше, копіювати групи з попереднього рядка там, де немає нижньої стінки.
			for j in cols:
				if maze[i - 1][j].has_bottom_wall:
					row[j].group = free_group
					free_group += 1
				else:   # Клітинки, які залишились, заповнити новими групами
					row[j].group = maze[i - 1][j].group

		# Потім - додати бокові стінки
		for j in cols:
			# Додати стінку якщо:
			# це остання клітинка
			# АБО наступна клітинка має таку ж групу
			# АБО випадково ПРИ УМОВІ що це не останній рядок
			if j == cols - 1 || row[j].group == row[j + 1].group || (i < rows - 1 && deside()):
				row[j].has_right_wall = true
			else:
				var target_group = row[j + 1].group
				for x in cols:
					if row[x].group == target_group:
						row[x].group = row[j].group

		# І додати стінки знизу
		if i < rows - 1:
			for j in cols:
				if row[j].has_right_wall:
					var group_has_hole = false
					for x in j:
						if row[x].has_bottom_wall == false && row[x].group == row[j].group:
							group_has_hole = true
					row[j].has_bottom_wall = deside() if group_has_hole else false
					group_has_hole = false
				elif deside():
					row[j].has_bottom_wall = true
		else:
			for j in cols:
				row[j].has_bottom_wall = true
	return maze
```

До початку воєнних дій російський Балтійський флот значно поступався німецькому
кайзерівському флоту, тому усі його плани будувалися з розрахунку на підтримку
дій своїх наземних сил. Втім, кайзерівський флот для дій на Балтійському
морі обмежився незначним угрупованням бойових кораблів, яке виконувало
другорядні завдання. З початку серпня 1914 року розпочалися бойові дії, які
скоріше мали характер розвідки боєм, ніж повномасштабних бойових зіткнень
флотів двох держав. Протягом кампанії 1914 року російський Балтійський флот
перейшов від пасивного очікування противника в гирлі Фінської затоки до
активних дій на всій акваторії моря.
