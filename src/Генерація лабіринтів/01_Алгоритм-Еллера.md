# Алгоритм Еллера

## Суть алгоритму

### Що це таке?

Алгоритм еллера — це алгоритм для генерації *ідеальних лабіринтів*.
Ідеальними лабіринтами називають такі, які не мають закритих областей
(таких в які не можна потрапити з іншої частини лабіринту)
та циклів (тобто, між будь-якими двома точками є лише один можливий шлях).

### Як працює алгоритм

Алгоритм створює лабіринт рядок за рядком.
Для кожної клітинки потрібно знати,
чи має вона стінку знизу та стінку справа,
а також групу, до якої вона належить.
Про стінки зліва та зверху знати не потрібно,
так як верхня стінка - це нижня стінка клітинки вище й ліва стінка - це права для лівої клітинки відповідно.
Для найвищих та найлівіших клітинок ми приймемо, що всі вони мають стінки зверху та зліва.


Спершу, створімо перший ряд, і назначмо кожній клітинці в ньому свою унікальну групу:
![Перший ряд з унікальними групами](images/eller-1.webp)
Після цього, рухаючись з ліва на право, розмістімо стінки справа.
Для кожної пари клітинок ми можемо прийняти рішення, ставити там стінку чи ні.
Якщо ми вирішили не ставити стінку між клітинками, то повинні об'єднати їх групи.
Для останної клітинки ми зобор'язані поставити стінку справа:
![Перший ряд із стінками та об'єднаними групами](images/eller-2.webp)
Тепер, розставімо нижні стінки.
Кожна група повинна мати хоч одну дірку знизу, інакше утвориться закрита зона:
![Перший ряд із нижніми стінками](images/eller-3.webp)
Після цього зкопіюймо групи до нижнього ряду, але лише там де клітинки не мають стінок знизу:
![Другий ряд з копіями груп](images/eller-4.webp)
Тим же клітинкам, які залишились назначмо нові групи:
![Другий ряд, повністю заповнений групами](images/eller-5.webp)
Після цього, як і в пепередньому рядку, знову розставімо стінки справа.
І якщо дві сусідні клітинки мають різні групи, то ми або можемо поставити між ними стінку:
![Можлива стінка зліва](images/eller-6.webp)
або можемо об'єднати їх в одну групу:
![Стінка не поставлена](images/eller-7.webp)
Якщо ж сусідні клітинки належать до однієї групи:
![Можлива стінка 2](images/eller-8.webp)
то ми **зобов'язані** поставити між ними стінку, щоб в лабіринті ну утворився цикл:
![Стінка поставлена](images/eller-9.webp)
Після цього нам знову потрібно розставити нижні стінки.
Не забувайте, що кожна група повинна мати хоч одну дірку знизу:
![Стінки знизу в другому рядку](images/eller-10.webp)
Також, візьміть до уваги, якщо ми хочемо об'єднати дві групи потрібно змінити групу у всіх клітинках
які належать до групи яку ми хочемо приєднати.
На відміну від того, що показано на зображенні вам не потрібно змінювати групи в попередніх рядках.
Проте потрібно змінити всі клітинки в ряді з яким ми зараз працюємо.
Себто, якби в третьому рядку було декілька клітинок **першої групи**,
ми повинні були б приєднати їх усіх до **сьомої**:
![Можна об'єднати групи](images/eller-11.webp)
![Групи об'єднані](images/eller-12.webp)
Таким чином ми можемо продовжувати безкінечно, додаючи нові ряди:
![Третій ряд закфнчений](images/eller-13.webp)
Якщо ж ми хочемо закінчити лабіринт,
то тепер, в останньому рядку, ми повинні завжди об'єднувати дві сусідні групи, якщо вони різні.
Та завжди ставити між клітинками стінку якщо їх групи однакові:
![Останній ряд без стінок](images/eller-14.webp)
Так як нижній ряд останній в лабіринті, кожна клітинка в ньому повинна мати стінку знизу:
![Закінчений лабіринт](images/eller-15.webp)

## Реалізація

Ось моя реалізація алгоритму на мові GDscript:

```
func eller(rows: int, cols: int) -> Array:
	var maze = create_array2D(rows, cols)
	var free_group = 0

	for i in rows:
		var row = maze[i]

		# Спершу, потрібно заповнити ряд групами
		if i == 0:  # Якщо це перший рядок: зоповнити його повністю новими значеннями
			for j in cols:
				row[j].group = free_group
				free_group += 1
		else:   # Інакше, копіювати групи з попереднього рядка там, де немає нижньої стінки.
			for j in cols:
				if maze[i - 1][j].has_bottom_wall:
					row[j].group = free_group
					free_group += 1
				else:   # Клітинки, які залишились, заповнити новими групами
					row[j].group = maze[i - 1][j].group

		# Потім - додати бокові стінки
		for j in cols:
			# Додати стінку якщо:
			# це остання клітинка
			# АБО наступна клітинка має таку ж групу
			# АБО випадково ПРИ УМОВІ що це не останній рядок
			if j == cols - 1 || row[j].group == row[j + 1].group || (i < rows - 1 && deside()):
				row[j].has_right_wall = true
			else:
				var target_group = row[j + 1].group
				for x in cols:
					if row[x].group == target_group:
						row[x].group = row[j].group

		# І додати стінки знизу
		if i < rows - 1:
			for j in cols:
				if row[j].has_right_wall:
					var group_has_hole = false
					for x in j:
						if row[x].has_bottom_wall == false && row[x].group == row[j].group:
							group_has_hole = true
					row[j].has_bottom_wall = deside() if group_has_hole else false
					group_has_hole = false
				elif deside():
					row[j].has_bottom_wall = true
		else:
			for j in cols:
				row[j].has_bottom_wall = true
	return maze
```
У цьому коді, клітинка лабіринту описується ось таким класом:
```
class MazeCell:
	extends Reference

	export var group : int
	export var has_bottom_wall : bool
	export var has_right_wall : bool
```
Окрім цього, я використовую дві прості функції.
Одна, повертає значення `true` з імовірністю 50%:
```
func deside() -> bool:
	return randf() > 0.5
```
А інша - займається створенням масиву масивів клітинок, який і буде нашим лабіринтом:
```
func create_array2D(rows: int, cols: int) -> Array:
	var arr = []
	for i in rows:
		arr.append([])
		for j in cols:
			arr[i].append(MazeCell.new())
	return arr
```

## Висновок

Алгоритм еллера створює лабіринти високої якості.
Ось декілька прикладів:

![Більший лабіринт](images/eller-maze.webp)
![Менший лабіринт](images/eller-maze2.webp)

Алгоритм працює досить швидко, а створені ним лабіринти не мають всіляких артефактів чи очевидних шляхів.
Також, так як для роботи алгоритму потрібно знати лише попередній ряд,
алгоритм підходить для створення безкінечних лабіринтів.
Принаймні, безкінечних в одному напрямку.
Таким чином можна, на приклад, зробити генерацію безконечного підземелля для гри платформера.
Також, можна генерувати нові рядки в обидва боки,
тоді лабіринт буде повністю безконечним по-вертикалі.
Або, зробити радіальний лабіринт, де замість рядків будуть генеруватись кільця.
Тоді лабіринт буде нескінченним у всіх напрямках.

